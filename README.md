Наша задача написать что-то, что отличалось бы от других ребят и существующих ЯП, поэтому предлагаю следующее.

Чтобы самим было проще понимать свой же ЯП предлагаю установить правила:
1) тип должен быть всегда как можно левее всегда и везде.
2) все должно быть вида Что-то(аргументы)
3) все названия должны быть краткими
4) если мы объявляем тип переменной, то он всегда оканчивается ; (Н. int a b c; char g h)

---

# Переменные

Описание типов:

int
float
char
bool
void

---

# Операторы

Арифметические операторы:

- `+` Добавляет два операнда.
- `-` Вычитает второй операнд с первого.
- `*` Умножает оба операнда.
- `/` Делит числитель на де-числитель.
- `%` Оператор модуля и остаток после целочисленного деления.
- `++` Оператор приращения увеличивает целочисленное значение на единицу (инкремент).
- `--` Оператор приращения уменьшает целочисленное значение на единицу (декремент).

Реляционные операторы:

- `==` Проверяет, равны ли значения двух операндов или нет, если да, то условие становится истинным.
- `~=` Проверяет, равны ли значения двух операндов или нет, если значения не равны, условие становится истинным.
- `>` Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.
- `<` Проверяет, является ли значение левого операнда меньше значения правильного операнда, если да, тогда условие становится истинным.
- `=>` Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.
- `<=` Проверяет, является ли значение левого операнда меньше или равно значению правильного операнда, если да, тогда условие становится истинным.

Логические операторы:

- `and` Является логическим оператором `И`.
- `or` Является логическим оператором `ИЛИ`.
- `~` Является логическим оператором `НЕ`.

Операторы присваивания:

- `=` Простой оператор присваивания, присваивает значения из правых операндов в левый операнд.

---

# Циклы

Циклы обозначаются ключевым словом `do` и `for`.
  
  Пример для `do`. Он будет вместо `while`:
  
  ```bayl
  do (i < 239) {
      // loop body
  }
  ```
  
  В этом примере цикл будет продолжать выполняться до тех пор, пока `i` значение меньше 239, и `i`.


- `for`:

  ```bayl
  int i;
  i = 0;
  
  for (i < 239 | i++) {
      // loop body
  }
  ```

---

# Функции

Общая форма функции:

```bayl
тип -> имя_функции(тип_параметра1 имя_параметра1 имя_параметра2; тип_параметра2 имя_параметра3 имя_параметра4) => имя_возвращаемого_значения {
    // тело функции
    return
}
```

Описание компонентов функции:

- `->`: ключевое слово, обозначающее начало определения функции.
- `имя_функции`: имя, данное функции для ее идентификации и вызова.
- `(тип_параметра1 имя_параметра1 имя_параметра2; тип_параметра2 имя_параметра3 имя_параметра4)`: список параметров функции, разделенных точкой с запятой. Каждый параметр состоит из типа данных и имени параметра.
- `=> имя_возвращаемого_значения`: указание типа возвращаемого значения и его имени. Если функция не возвращает значение, эта часть может быть опущена.
- `{ // тело функции }`: тело функции, содержащее операторы, которые выполняются при вызове функции.
- `return`: оператор, указывающий на завершение функции и возвращение значения. Если функция не возвращает значение, этот оператор может быть опущен.

как последняя мера - можно return заменить на ret

Пример функции:

```bayl
int -> sum(int a b;) => x {
    int x = a + b;

    // вернет значение x //
    return
}
```

# Массивы

Методы массива:

```bayl
int(3) array;

array.0 = 239;

for (int i = 0 < array.len | i++) {
     array.i = 239;
}
```

---

# Комментарии

Комментарии обозначаются символом `$`. Любой текст, следующий за символом `$` на строке, будет проигнорирован компилятором.

коммены я бы сделал // сам коммент //

Пример:

```bayl
void -> main() => {
    int x;
    x = 2 + 3;
    // 239 //
    return
}
```
