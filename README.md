Наша задача написать что-то, что отличалось бы от других ребят и существующих ЯП, поэтому предлагаю следующее.

Чтобы самим было проще понимать свой же ЯП предлагаю установить правила:
1) тип должен быть всегда как можно левее всегда и везде.
2) все должно быть вида Что-то(аргументы)
3) все названия должны быть краткими
4) если мы объявляем тип переменной, то он всегда оканчивается ; (Н. int a b c; char g h)

# Примеры_синтаксиса

--- 

# Переменные

Во-первых, что у нас вообще будет (int, char, ???float???, bool)

```baye
int a b c;
char h k;
```

как видно из примера, разделители у нас - пробелы, а в конце ";", как и в конце любой строки.

Иерархия типов:

- Object -> Numeric -> (Integer -> (Short, Long) , Float, Complex*)
- Object -> String -> Symbol
- Object -> Array
- Object -> Struct*

---

# Циклы

Конечно, for можно сократить до fr, а while до  wh, но мне пока это кажется уже слишком, хотя если итог енивей будет похож на что-то, то я бы все-таки задумался.

```bayl
for (int i < 239 : i++) [
//...code...//
]
```

Да, для разделения логики я предлагаю использовать [], тк это не похоже ни на что + их быстрее прожимать. Как видно, переменная цикла объявляется сразу с условием по типу: тип имя условие другая переменная / значение далее - : и то, как она изменится.

while особо не изменишь, если не прибегать к сокращению в wh, конечно.

```bayl
while (i < 239) [
//...code...//
]
```

И да, я бы если и делал комменты, то только так, чтобы они в конце тоже имели бы //, хотя мне кажется они вообще не нужны.

На всякий примеры с сокращением.

```bayl
fr (int i < 239 : i++) [
//...code...//
]
```

```bayl
wh (i < 239) [
//...code...//
]
```


@bloom_guy: Предлагаю не ебать мозги и просто сделать for без обязательного объявления инициатора->условия->пост-оператора. Назвать do, не лучше чем fr и wh, но более осмысленно

```bayl
do (int i < 239 : i++) {
	// something
}
```

```bayl
do (j < 228) {
	// something
}
```

#Функции

Тут бы я тоже придерживался сокращений и типа как можно левее.

пример:

```bayl
int fn sum(int a b;) [
	return a + b;
]
```

Тут как раз видно правило на ; в конце каждого объявления типов переменных.
Кстати, return, в целом, тоже можно сократить до ret.

пример:

```bayl
int fn sum(int a b;) [
	ret a + b;
]
```

@bloom_guy: Мы вроде это уже обсуждали, не знаю нахуя опять что-то начали придумывать:

```bayl
fun funcName(int a b c; string d e) => [int x] {
        int x = a+b+c;
        string y = d+e;
        return
}
```

#Массивы

Здесь предлагаю не отходить от нашего вида: тип название ().

пример:

```bayl
int arr(3) array;
```

или 

```bayl
int(3) array;
```

Первый вариант с составным типом очень похож на то, как в гооол сделаны каналы (ch chan string).

В данных примерах array - имя, а int - тип. Для первого примера arr - ключевое слово для создания массивов. В обоих случаях я думаю будет лучше всегда требовать указывать длину.

Обращаться к элементам я предполагаю через . как и к его длине.

пример:

```bayl
int fn main() [
	int a;
	a = 3;
	int arr(a) array;
	array.0 = 239;
	array.1 = 240;
	array.(a - 1) = 241;
]
```


Таким образом язык будет более-менее понятным (хотя бы для создателей) + мы будем сильно отличаться от всех + у нас даже будут основные правила для всего, что тоже немаловажно).

По поводу названия. Оно мне пришло рандомно и очень понравилось.
Как расширение можно взять .bl

# Комментарии

Проще всего для нас будет сделать однострочные. 
Пусть это будет любой символ по типу: $, #, @, ...
