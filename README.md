Наша задача написать что-то, что отличалось бы от других ребят и существующих ЯП, поэтому предлагаю следующее.

Чтобы самим было проще понимать свой же ЯП предлагаю установить правила:
1) тип должен быть всегда как можно левее всегда и везде.
2) все должно быть вида Что-то(аргументы)
3) все названия должны быть краткими
4) если мы объявляем тип переменной, то он всегда оканчивается ; (Н. int a b c; char g h)

---

# Переменные

Иерархия типов:

- Object -> Numeric -> (Integer -> (Short, Long) , Float)
- Object -> String -> Symbol
- Object -> Array
- Object -> Bool
- Object -> Null
- Object -> func

Описание типов:

- Integer: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)
- Short: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)
- Long: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)
- Float: представляет вещественное число от -2147483648 до 2147483647 одинарной точности с плавающей точкой и занимает 4 байта (32 бита)
- String: представляет строки которым соответствует строковый литерал - последовательность символов, заключенная в двойные кавычки. Строки имутабельны, но при этом их можно расширять (для этого есть метод `+`). Можно также реализовать методы `.reverse` и `.toSymbols`, которые разворачивают и переводят строку в массив `Symbol`-ов соответственно. Кроме обычных символов строка может содержать специальные последовательности (управляющие последовательности), которые начинаются с обратного слеша `\ `.
     + `\br`: переход на новую строку
     + `\"`: двойная кавычка внутри строк
     + `\\`: обратный слеш
- Symbol: представляет одиночный символ в кодировке Unicode и занимает в памяти 2 байта (16 бит).
- Array: представляет набор элементов одного типа данных, хранящихся в смежных ячейках памяти. 
- Bool: представляет логическое значение, которое может быть либо `true`, либо `false`.
- Null: представляет отсутствие значения или null-объект.
- func: представляет функцию, которая может быть вызвана с аргументами и возвращать значение.

---

# Операторы

Арифметические операторы:

- `+` Добавляет два операнда.
- `-` Вычитает второй операнд с первого.
- `*` Умножает оба операнда.
- `/` Делит числитель на де-числитель.
- `%` Оператор модуля и остаток после целочисленного деления.
- `++` Оператор приращения увеличивает целочисленное значение на единицу (инкремент).
- `--` Оператор приращения уменьшает целочисленное значение на единицу (декремент).

Реляционные операторы:

- `==` Проверяет, равны ли значения двух операндов или нет, если да, то условие становится истинным.
- `===` Проверяет, равны ли значения и тип двух операндов или нет, если да, то условие становится истинным.
- `!=` Проверяет, равны ли значения двух операндов или нет, если значения не равны, условие становится истинным.
- `>` Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.
- `<` Проверяет, является ли значение левого операнда меньше значения правильного операнда, если да, тогда условие становится истинным.
- `=>` Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.
- `<=` Проверяет, является ли значение левого операнда меньше или равно значению правильного операнда, если да, тогда условие становится истинным.

Логические операторы:

- `and` Является логическим оператором `И`.
- `or` Является логическим оператором `ИЛИ`.
- `~` Является логическим оператором `НЕ`.

Операторы присваивания:

- `=` Простой оператор присваивания, присваивает значения из правых операндов в левый операнд.
- `+=` Оператор Add AND присваивания, Он добавляет правый операнд в левый операнд и присваивает результат левому операнду.
- `-=` Subtract AND assign operator, вычитает правый операнд из левого операнда и присваивает результат левому операнду.
- `*=` Оператор умножения и присваивания, Он умножает правый операнд на левый операнд и присваивает результат левому операнду.
- `/=` Оператор Divide AND assign. Он делит левый операнд на правый операнд и присваивает результат левому операнду.
- `%=` Модуль и оператор присваивания, он принимает модуль с использованием двух операндов и присваивает результат левому операнду.

---

# Циклы

Циклы обозначаются ключевым словом `do`. Существует два типа циклов: `do` с инкрементором и `do` без инкрементора.

- `do` с инкрементатором:

  ```bayl
  do (condition | incrementor) {
      // loop body
  }
  ```
  
  Цикл `do` с инкрементом похож на `for` цикл в других языках. Он состоит из условия и инкремента.
  
  Пример:
  
  ```bayl
  do (i < 239 | i++) {
      // loop body
  }
  ```
  
  В этом примере цикл будет продолжать выполняться до тех пор, пока `i` значение меньше 239, и `i` будет увеличиваться на 1 после каждой итерации.


- `do` без инкрементора:

  ```bayl
  do (condition) {
      // loop body
  }
  ```

  Цикл `do` без инкрементора похож на `while` цикл в других языках. Он состоит только из условия.

  Пример:

  ```bayl
  do (i < 239) {
    // loop body
  }
  ```
  
  В этом примере цикл будет продолжать выполняться до тех пор, пока `i` значение меньше 239.

Примечания:

- Условием в `do` цикле может быть любое допустимое логическое выражение.
- Инкрементором в `do` цикле с инкрементором может быть любое допустимое выражение, которое изменяет переменную цикла.
- Тело цикла может содержать любые допустимые операторы.

---

# Функции

Общая форма функции:

```bayl
func имя_функции(тип_параметра1 имя_параметра1 имя_параметра2; тип_параметра2 имя_параметра3 имя_параметра4) => [тип_возвращаемого_значения имя_возвращаемого_значения] {
    // тело функции
    return
}
```

Описание компонентов функции:

- `func`: ключевое слово, обозначающее начало определения функции.
- `имя_функции`: имя, данное функции для ее идентификации и вызова.
- `(тип_параметра1 имя_параметра1 имя_параметра2; тип_параметра2 имя_параметра3 имя_параметра4)`: список параметров функции, разделенных точкой с запятой. Каждый параметр состоит из типа данных и имени параметра.
- `=> [тип_возвращаемого_значения имя_возвращаемого_значения]`: указание типа возвращаемого значения и его имени. Если функция не возвращает значение, эта часть может быть опущена.
- `{ // тело функции }`: тело функции, содержащее операторы, которые выполняются при вызове функции.
- `return`: оператор, указывающий на завершение функции и возвращение значения. Если функция не возвращает значение, этот оператор может быть опущен.

Пример функции:

```bayl
func funcName(Integer a b c; String d e) => [int x y] {
    Integer x = a+b+c;
    String y = d+e;
    return
}
```

# Массивы

Методы массива:

- `.size(n)`: устанавливает размер массива равным `n` элементам
- `.reverse()`: меняет порядок элементов в массиве на обратный
- `.get(i)`: извлекает элемент по индексу `i` в массиве
- `.set(i)`: устанавливает элемент по индексу `i` в массиве

Пример:
```bayl
$ Declare an array with initial size 5
Array myArray = Array.size(5);

$ Initialize elements of the array
myArray.set(0, 10);
myArray.set(1, 20);
myArray.set(2, 30);
myArray.set(3, 40);
myArray.set(4, 50);

$ Print the array
print(myArray); $ Output: [10, 20, 30, 40, 50]

$ Reverse the array
myArray.reverse();

$ Print the reversed array
print(myArray); $ Output: [50, 40, 30, 20, 10]

$ Get the element at index 2
print(myArray.get(2)); $ Output: 30

$ Set the element at index 2 to 35
myArray.set(2, 35);

$ Print the modified array
print(myArray); $ Output: [50, 40, 35, 20, 10]

$ Resize the array to 3 elements
myArray.size(3);

$ Print the resized array
print(myArray); $ Output: [50, 40, 35]
```

---

# Комментарии

Комментарии обозначаются символом `$`. Любой текст, следующий за символом `$` на строке, будет проигнорирован компилятором.

Пример:

```bayl
Func funcName(Integer a b c; String d e) => [int x y] {
    Integer x = a+b+c; $ Это комментарий
    String y = d+e; $ И это тоже
    return $ И даже тут
}
```
