Наша задача написать что-то, что отличалось бы от других ребят и существующих ЯП, поэтому предлагаю следующее.

Чтобы самим было проще понимать свой же ЯП предлагаю установить правила:
1) тип должен быть всегда как можно левее всегда и везде.
2) все должно быть вида Что-то(аргументы)
3) все названия должны быть краткими
4) если мы объявляем тип переменной, то он всегда оканчивается ; (Н. int a b c; char g h)

---

# Переменные

Описание типов:

int
float
char
bool

---

# Операторы

Арифметические операторы:

- `+` Добавляет два операнда.
- `-` Вычитает второй операнд с первого.
- `*` Умножает оба операнда.
- `/` Делит числитель на де-числитель.
- `%` Оператор модуля и остаток после целочисленного деления.
- `++` Оператор приращения увеличивает целочисленное значение на единицу (инкремент).
- `--` Оператор приращения уменьшает целочисленное значение на единицу (декремент).

Реляционные операторы:

- `==` Проверяет, равны ли значения двух операндов или нет, если да, то условие становится истинным.
- `~=` Проверяет, равны ли значения двух операндов или нет, если значения не равны, условие становится истинным.
- `>` Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.
- `<` Проверяет, является ли значение левого операнда меньше значения правильного операнда, если да, тогда условие становится истинным.
- `=>` Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.
- `<=` Проверяет, является ли значение левого операнда меньше или равно значению правильного операнда, если да, тогда условие становится истинным.

Логические операторы:

- `and` Является логическим оператором `И`.
- `or` Является логическим оператором `ИЛИ`.
- `~` Является логическим оператором `НЕ`.

Операторы присваивания:

- `=` Простой оператор присваивания, присваивает значения из правых операндов в левый операнд.

---

# Циклы

Циклы обозначаются ключевым словом `do`. Существует два типа циклов: `do` с инкрементором и `do` без инкрементора.
  
  Цикл `do` с инкрементом похож на `for` цикл в других языках. Он состоит из условия и инкремента.
  
  Пример:
  
  ```bayl
  do (int i < 239 | i++) {
      // loop body
  }
  ```
  
  В этом примере цикл будет продолжать выполняться до тех пор, пока `i` значение меньше 239, и `i` будет увеличиваться на 1 после каждой итерации.


- `do` без инкрементора:

  ```bayl
  do (condition) {
      // loop body
  }
  ```

  Цикл `do` без инкрементора похож на `while` цикл в других языках. Он состоит только из условия.

  Пример:

  ```bayl
  do (i < 239) {
    // loop body
  }
  ```
  
  В этом примере цикл будет продолжать выполняться до тех пор, пока `i` значение меньше 239.

Примечания:

- Условием в `do` цикле может быть любое допустимое логическое выражение.
- Инкрементором в `do` цикле с инкрементором может быть любое допустимое выражение, которое изменяет переменную цикла.
- Тело цикла может содержать любые допустимые операторы.

---

# Функции

Общая форма функции:

```bayl
func имя_функции(тип_параметра1 имя_параметра1 имя_параметра2; тип_параметра2 имя_параметра3 имя_параметра4) => [тип_возвращаемого_значения имя_возвращаемого_значения] {
    // тело функции
    return
}
```

Описание компонентов функции:

- `func`: ключевое слово, обозначающее начало определения функции.
- `имя_функции`: имя, данное функции для ее идентификации и вызова.
- `(тип_параметра1 имя_параметра1 имя_параметра2; тип_параметра2 имя_параметра3 имя_параметра4)`: список параметров функции, разделенных точкой с запятой. Каждый параметр состоит из типа данных и имени параметра.
- `=> [тип_возвращаемого_значения имя_возвращаемого_значения]`: указание типа возвращаемого значения и его имени. Если функция не возвращает значение, эта часть может быть опущена.
- `{ // тело функции }`: тело функции, содержащее операторы, которые выполняются при вызове функции.
- `return`: оператор, указывающий на завершение функции и возвращение значения. Если функция не возвращает значение, этот оператор может быть опущен.

Пример функции:

```bayl
func funcName(Integer a b c; String d e) => [int x y] {
    Integer x = a+b+c;
    String y = d+e;
    return
}
```

# Массивы

Методы массива:

```bayl
int(3) array;

array.0 = 239;
```

---

# Комментарии

Комментарии обозначаются символом `$`. Любой текст, следующий за символом `$` на строке, будет проигнорирован компилятором.

Пример:

```bayl
Func funcName(Integer a b c; String d e) => [int x y] {
    Integer x = a+b+c; $ Это комментарий
    String y = d+e; $ И это тоже
    return $ И даже тут
}
```
